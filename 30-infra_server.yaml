- name: Install infra-server
  hosts: infra_server
  become: yes
  
  vars_files:

    - group_vars/file_server/secrets.yml
    - group_vars/file_server/common.yml

  tasks:

    - name: Install required packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - htop
          - iotop
          - strace
          - lsof
          - mc
          - firewalld
          - smbclient 
          - cifs-utils 
          - podman
          - podman-docker
          - auditd
          - apparmor-utils
          - apparmor-profiles
          - jq          
        state: present
        update_cache: yes

    - name: Ensure Firewalld is running and enabled
      ansible.builtin.systemd:
        name: firewalld
        enabled: yes
        state: started

    - name: Check existing Firewalld zones
      ansible.builtin.command: "firewall-cmd --get-zones"
      register: firewalld_existing_zones
      changed_when: false

    - name: Create Firewalld zones if missing
      ansible.builtin.firewalld:
        zone: "{{ item }}"
        permanent: yes
        state: present
      loop:
        - servers
        - 10G
        - smb
        - containers
      when: "item not in firewalld_existing_zones.stdout"

    - name: Reload Firewalld to apply new zones
      ansible.builtin.command:
        cmd: "firewall-cmd --reload"
      changed_when: false 
       
    - name: Bind interfaces to Firewalld zones
      ansible.builtin.firewalld:
        zone: "{{ item.zone }}"
        interface: "{{ item.interface }}"
        permanent: yes
        immediate: yes
        state: enabled
      loop:
        - { zone: "servers", interface: "eth0" }
        - { zone: "10G", interface: "eth1" }
        - { zone: "smb", interface: "eth3" }
        - { zone: "containers", interface: "eth2" }

    - name: Allow required services in Firewalld zones
      ansible.builtin.firewalld:
        zone: "{{ item.zone }}"
        service: "{{ item.service }}"
        permanent: yes
        immediate: yes
        state: enabled
      loop:
        - { zone: "servers", service: "ssh" }
        - { zone: "servers", service: "dns" }
        - { zone: "servers", service: "dhcp" }
        - { zone: "servers", service: "ntp" }
        - { zone: "smb", service: "samba-client" }
        - { zone: "10G", service: "dns" }
        - { zone: "10G", service: "dhcp" }
        - { zone: "10G", service: "ntp" }
        
    - name: Open required ports in Firewalld zones
      ansible.builtin.firewalld:
        zone: "{{ item.zone }}"
        port: "{{ item.port }}"
        permanent: yes
        immediate: yes
        state: enabled
      loop:
        - { zone: "containers", port: "8080/tcp" }
        - { zone: "containers", port: "8081/tcp" }

    - name: Enable IP forwarding
      sysctl:
        name: net.ipv4.ip_forward
        value: '1'
        sysctl_set: yes
        state: present
        reload: yes
      
    - name: Redirect common ports for rootless podman (rich rules)
      ansible.posix.firewalld:
        zone: "{{ item.zone }}"
        rich_rule: 'rule family="ipv4" forward-port port="{{ item.src_port }}" protocol="{{ item.protocol }}" to-port="{{ item.to_port }}"'
        permanent: yes
        immediate: yes
        state: enabled  
      loop:
        - { zone: "servers", src_port: 53,  protocol: "tcp", to_port: 8053 }
        - { zone: "servers", src_port: 53,  protocol: "udp", to_port: 8053 }
        - { zone: "servers", src_port: 67,  protocol: "tcp", to_port: 8067 }
        - { zone: "servers", src_port: 67,  protocol: "udp", to_port: 8067 }
        - { zone: "servers", src_port: 123, protocol: "udp", to_port: 8123 }
        - { zone: "10G",    src_port: 53,  protocol: "tcp", to_port: 8053 }
        - { zone: "10G",    src_port: 53,  protocol: "udp", to_port: 8053 }
        - { zone: "10G",    src_port: 67,  protocol: "tcp", to_port: 8067 }
        - { zone: "10G",    src_port: 67,  protocol: "udp", to_port: 8067 }
        - { zone: "10G",    src_port: 123, protocol: "udp", to_port: 8123 }        

    - name: Reload Firewalld to apply changes
      ansible.builtin.command:
        cmd: "firewall-cmd --reload"

    - name: Ensure user 'infra' exists with a specific password
      ansible.builtin.user:
        name: infra
        shell: /bin/bash
        home: /home/infra
        state: present
        create_home: true
        password: "{{ infra_password }}" 
        
    - name: Ensure infra has authorized SSH key
      ansible.posix.authorized_key:
        user: infra
        state: present
        key: "{{ infra_ssh_pubkey }}"

    - name: Ensure aliases are present in .bashrc for root, podman and michael
      ansible.builtin.lineinfile:
        path: "{{ item.bashrc }}"
        line: "{{ item.alias }}"
        create: yes
        owner: "{{ item.user }}"
        group: "{{ item.user }}"
        mode: '0644'
        insertafter: EOF
      loop:
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias gs='git status'" }
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias c='clear'" }
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias h='history'" }
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias ls='ls -alh --color=auto" }
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias df='df -h'" }
        - { user: 'root', bashrc: '/root/.bashrc', alias: "alias ports='ss -tulpn''" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias gs='git status'" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias c='clear'" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias h='history'" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias ls='ls -alh --color=auto'" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias df='df -h'" }
        - { user: 'michael', bashrc: '/home/michael/.bashrc', alias: "alias ports='ss -tulpn'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias gs='git status'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias c='clear'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias h='history'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias ls='ls -alh --color=auto'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias df='df -h'" }
        - { user: 'podman', bashrc: '/home/podman/.bashrc', alias: "alias ports='ss -tulpn'" }

    - name: Fetch latest Docker Compose release via GitHub API
      uri:
        url: https://api.github.com/repos/docker/compose/releases/latest
        return_content: yes
        status_code: 200
      register: compose_release
      retries: 3
      delay: 5
      until: compose_release.status == 200

    - name: Determine Docker Compose version (fallback if API fails)
      set_fact:
        compose_version: >-
          {{ compose_release.json.tag_name
             if (compose_release.json is defined and compose_release.json.tag_name is defined)
             else 'v2.18.1' }}

    - name: Download Docker Compose standalone binary
      get_url:
        url: "https://github.com/docker/compose/releases/download/{{ compose_version }}/docker-compose-{{ ansible_system | lower }}-{{ ansible_architecture }}"
        dest: /usr/local/bin/docker-compose
        mode: '0755'
      notify: Controleer docker-compose

    - name: Get infra user's UID
      command: id -u infra
      register: infra_uid_cmd
      changed_when: false

    - name: Set infra_uid fact
      set_fact:
        podman_uid: "{{ podman_uid_cmd.stdout }}"

    - name: Enable linger for infra user so socket survives reboot
      command: loginctl enable-linger infra

    - name: Ensure podman.socket is enabled and running for infra user
      command: >
        sudo -u podman env XDG_RUNTIME_DIR=/run/user/{{ infra_uid }}
        systemctl --user enable --now podman.socket

    - name: Get infra user's UID
      ansible.builtin.command:
        cmd: "id -u infra"
      register: infra_uid_cmd
      changed_when: false

    - name: Get infra user's GID
      ansible.builtin.command:
        cmd: "id -g infra"
      register: infra_gid_cmd
      changed_when: false

    - name: Create CIFS credentials file for infra
      ansible.builtin.copy:
        dest: /etc/samba/credentials/infra
        content: |
          username=infra
          password={{ infra_smb_password }}
        owner: root
        group: root
        mode: '0600'

    - name: Ensure mountpoint directory exists
      ansible.builtin.file:
        path: /home/infra/data
        state: directory
        owner: infra
        group: infra
        mode: '2770'

    - name: Mount infra-server Samba share for Podman
      ansible.builtin.mount:
        path: /home/infra/data
        src: "//10.13.112.20/infra-server"
        fstype: cifs
        opts: >-
          credentials=/etc/samba/credentials/infra,
          uid={{ infra_uid_cmd.stdout }},
          gid={{ infra_gid_cmd.stdout }},
          vers=3.1.1,
          sec=ntlmssp,
          noperm,
          file_mode=0660,
          dir_mode=02770,
          _netdev,
          noauto,
          x-systemd.automount,
          x-systemd.idle-timeout=1min,
          x-systemd.requires=network-online.target,
          x-systemd.after=network-online.target
        state: mounted

    - name: Reboot the server
      ansible.builtin.reboot:
        reboot_timeout: 600     # wait up to 10 minutes for reboot
        test_command: whoami    # command to verify SSH is back
      tags: reboot

    - name: Reset SSH connection after reboot
      meta: reset_connection
      tags: reboot

  handlers:
    - name: Controleer docker-compose
      command: docker-compose version
      register: compose_check
      changed_when: false
      failed_when: compose_check.rc != 0


